<?LaTeX ExtraPreamble="\usepackage[pdftex]{graphicx}"?>
<Chapter Label = "introduction">

  <Heading>
   aaa package
  </Heading>
  <Section Label = "The aaa package and the rational group">
<Heading>
   The aaa package and the rational group
  </Heading>
  This package grew out of a desire to be able to work efficiently with elements of the asychronous rational group as described in the paper <Cite Key = "GNS"/>.<P/>

  Note that there are already two related packages in GAP. The first package <Cite Key="FR"/> by Laurent Bartholdi is called "fr" and the second package by Yevgen Muntyan and Dmytro Savchuk <Cite Key="AUTOMGRP"/> is called "AutomGrp". 
  The packages "fr" and "AutoGrp" differ greatly in functionallity but are both meant to work with functionally recursive groups or semigroups generated by finite synchonous transducers (the (semi)groups can be either finite or infinite).<P/>
 
  The paper <Cite Key = "GNS"/> actually describes the group R of homeomorphisms of the binary Cantor space which are describable by finite initial asynchronous automata (the fact that the Cantor space is binary is not relevant). Groups generated by such homeomorphisms form a much broader class of groups; the group R contains many of the groups of homeomorphisms of Cantor space which are studied in the literature, such as the Thompson groups F, T, V, Grigorchuk's group, and hybrids such as Roever's group and other Nekrashevych type groups.<P/>

  The paper <Cite Key = "GNS"/> gives several algorithms for performing calculations in these groups and this package implements all of that functionality although occasionally using different underlying algorithms. The names of various algorithms are natural from the text of the paper as one can see in this manual.<P/>

  We will use the word "automaton" to represent a directed edge labelled graph where the edge labels come from a finite alphabet.
  We will use the word "transducer" to represent a machine which reads infinite strings according to the transitions of an automaton, but when transitioning over an edge the machine will write a finite word (possibly empty) which depends on the current state and input letter.
  A transducer will represent a group element in R if when reading from the initial state it induces a bijection on Cantor space (in our package the initial state is the state labelled ``1").<P/>

  This package is built over the framework provided by the automata package in GAP (https://www.gap-system.org/Packages/automata.html).<P/>
 </Section>

 <Section Label = "Examples">
<Heading>
   Examples
  </Heading>
 
  In the following sections we will work with the following transducers and demonstrate various aspects of the algorithms in <Cite Key = "GNS"/>.
<Example><![CDATA[	
gap> T := Transducer(2, 2, [[2, 3], [2, 3], [2, 3]],
>                          [[[], []], [[0], [0]], [[1], [1]]]);
<transducer with input alphabet on 2 symbols, output alphabet on 2 symbols,
  and 3 states.>
  ]]></Example>

For the reader, the first two numbers represent the input and output alphabet sizes. 
Inputting a positive integer n results the alphabet whose letters are the intergers between 0 and n-1 inclusive.
Then there is a list having an entry for each state of the machine. Each of these entries is a list which determines the transitions from that state when each input letter is read (there are 2 input letters in this example).
For example the first entry being the list [2, 3] indicates that we transition to state 2 when 0 is read from state 1, and we transition to state 3 when 1 is read from state 1.

Finally (similar to inputting transitions) there is a list of output words from each state when reading the corresponding input letter.
This notation seems obscure at first but it becomes easy to work with.
We also have the capacity to represent this transducer is a more human-readable form through an autogenerated pdf image of the transducer.
The following image is a representation of the transducer in the above example. 
 <Alt Only="LaTeX">
	\centerline{\includegraphics{first_transducer.pdf}}
 </Alt>


This image can be generated with the command: "Splash(DotTransducer(T))".

The example above  represents an inefficient transducer representing the identity homeomorphism on the two letter alphabet Cantor space.
In this document we will show how to check that the transducer represents a bijection on Cantor space, how to replace this transducer by a smaller transducer representing the same transformation, how to invert the transducer, how to take products of transducers, and in general, carry out the methods described in <Cite Key = "GNS"/>. <P/>

 </Section>

 <Section Label = "Main Functionality">
<Heading>
   Main Functionality
  </Heading>
  

  Our transducer package allows users to write transducers which change alphabet sizes, and do generic transducer-type transformations to finite strings.
  Given a base initial transducer T with identical input and output alphabets, the package can verify that T represents an invertible homeomorphism h of Cantor space.
  If h is invertible the package supports inversion (by producing a transducer S representing the inverse of h).
  It also supports taking products and supports the minimisation and checking for incomplete response procedures as described in the GNS paper.
  More detailed technical processes are also supported as one can see by reading further into this manual.<P/>
</Section>
  </Chapter>    
